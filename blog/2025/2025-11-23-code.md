---
layout: post
title: Code 1st. Ed
author: Arpon Sarker
date: 2025-11-23 12:26:51
categories: [technology]
tags: [compsci]
---

## Introduction
It has been a while, I think I may have borrowed this book from the beginning of semester 1. It is now the Sunday two days after my final assignment was due for this year. This book by Charles Petzold (a New Yorker) goes through some history but is mostly concerned with building a computer from scratch - albeit, theoretically. There is some overlap in this book with the Elements of Computing System (TECS) which is only natural from the objectives of both of these books. 

This book can be organised into 3 sections: circuitry, assemblage (of microprocessors), and last-minute tidbits of modern developments.

## Circuitry
The circuity developed from the definition of Morse code and Braille which was new to me as an introduction to binary codes commpmared to TECS. This then branched to telegraphs and relays as repeaters for long distance communication using morse code all over the USA. It then went over combining the relays (an electromagnet connected to ground and some voltage) to create logic gates to create half-adders, full adders, flip-flops, oscillators (an inverter in a loop), latches, selectors, decoders, a full RAM module and with associated machine code for the computer. 

## Assemblage
The assemblage of all the components included the history of the computing age from Charles Babbage, Ada Byron, Herman Hollerith, von Neumann and the introduction of transistors. The two classic microprocessors that were viewed were the Intel 8080 and the Motorala 6800 which were both 40-pin integrated circuits. We went through the machine code and assembly mnemonics for the Intel chip and its workings. Further than that was the introduction of ASCII and a little bit of Unicode. The bus was then introduced as a means to connect different boards and peripherals and would later be used on a motherboard or one main board which consisted of all the components of the computer (apart from peripherals). 

## Modern Developments
The first development was the Operating System which had its motivations in its creation from requiring a simpler way to input mmachine code into the machine rather than using a control panel of switches and a way for the computer to initialise the screen's display, enabling interrupts, and halting. This was done by using a keyboard to input code into a file system and using commands such as Write, Display, and Run. A ROM was used to bootstrap the OS code and for the ASCII character bitmap to the screen which shouldn't be modified. The three major functions of an operating system are

* Provides commands and utilities that perform rudimentary housekeeping regarding files.
* Loads program files into memory and executes them
* Connects to hardware of the computer using an API (no program should be able to do this itself)

Some other additional functions that were seen was time-sharing and hierarchical file systems. It did not go in-depth on security which was listed as a function in Computer Science Illustrated. 

Other developments that were explained was FPU or floating-point units which was sold separately to the microprocessor but could be connected but was harder to write code for due to having its own separate machine code. Fixed point is the binary point being in place such as having two places for the fractional component for a business or banking context whereas, using the scientific notation a decimal number could be expressed as a floating point number. This is either 4 bytes for single precision or 8 bytes for double precision which is from the ANSI/IEEE standard 754-1985. This effectively represents scientific notation using a sign bit, an exponent, and a mantissa.

After that was high and low languages where creating an assembler went from being done by hand to running an assembler program. Initially, the first assembler had to be written by hand but the subsequent assemblers could just use the assembler of a different machine which is called *cross-assembling*. Compilers convert the high-level programming language to the particular machine's machine code. This means the user can write a portable programming language to be used for different machines but there must be multiple compilers made for the programming language to different machine codes depending on the machine. 

Lastly, the graphical revolution came about from Xerox PARC which created a GUI for the OS to increase interactivity between human and computer. It also took vast amounts of memory back then just for storing a byte for R, G, and B values for each pixel. Other media such as movies and audio came about from CDs, DVDs, and lossy or lossless compression techniques such as JPEG or MPEG. Java was the last topic were this programming language is both compiled and interpreted since the high-level Java code was compiled into Java byte code for the JVM. A computer can then emulate the JVM by interpreting the byte codes which led way to platform-independent programming. 


## My Thoughts
I wish the structure of the book was more thought out for the last third as everything was quite disjointed as can be seen with the topics being laid out. Overall, this book is from 1999 and quite dated but the concepts are still prevalent to this day. Overall, this book helped me in understanding the circuitry needed and I had to go through the second edition to help support my understanding on **control signals** which is just from pure logic that different machine codes are encoded into the circuitry to do some sort of action that corresponds to that instruction. I think a further dive into the second edition might help me more but that will come after some time. Overall, this book was helpful and the time it took was worth it. 
